<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Legislative Network Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", Roboto;
        }
        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
        }
        .sidebar {
            padding: 1rem;
            border-right: 1px solid #e1e4e8;
            background: #f6f8fa;
            overflow-y: visible;
        }
        .main-content {
            position: relative;
        }
        .controls {
            margin-bottom: 1rem;
        }
        .search-box {
            width: 93%;
            padding: 8px;
            margin-bottom: 0.5rem;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }
        .filter-group {
            margin-bottom: 1rem;
            padding: 1rem;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }
        .filter-group h4 {
            margin: 0 0 0.5rem 0;
        }
        .filter-value {
            font-size: 0.9rem;
            color: #586069;
            margin-top: 0.25rem;
        }
        .select2-container {
            width: 100% !important;
            margin-top: 0.5rem;
        }
        .select2-container--default .select2-selection--single {
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            height: 38px;
            padding: 4px;
        }
        .select2-container--default .select2-selection--single .select2-selection__arrow {
            height: 36px;
        }
        .select2-container--default .select2-results__option--highlighted[aria-selected] {
            background-color: #0366d6;
        }
        .select2-dropdown {
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }
        .party-dot {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .party-D { background: #0366d6; }
        .party-R { background: #d73a49; }
        .party-I { background: #6a737d; }
        .legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: white;
            padding: 1rem;
            border-radius: 6px;
            border: 1px solid #e1e4e8;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .node-info {
            margin-top: 1rem;
            padding: 1rem;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
        }
        .bill-list {
            max-height: 800px;
            overflow-y: auto;
            margin-top: 1rem;
        }
        .bill-item {
            padding: 0.5rem;
            border-bottom: 1px solid #e1e4e8;
            font-size: 0.9rem;
        }
        .node-label {
            font-size: 8px;
            pointer-events: none;
            fill: #24292e;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
            margin: 1rem 0;
        }
        .stat-box {
            padding: 0.8rem;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value {
            font-size: 1.2rem;
            font-weight: bold;
            color: #0366d6;
        }
        .stat-label {
            font-size: 0.8rem;
            color: #586069;
            margin-top: 0.2rem;
        }
        .policy-tag {
            display: inline-block;
            padding: 2px 8px;
            background: #f1f8ff;
            border: 1px solid #c8e1ff;
            border-radius: 12px;
            font-size: 0.8rem;
            color: #0366d6;
            margin: 2px;
        }
        .bill-policy {
            margin-top: 0.3rem;
            font-size: 0.8rem;
            color: #0366d6;
        }
        .selected-node {
            stroke: #f1e05a !important;
            stroke-width: 3px !important;
        }
        .dimmed {
            opacity: 0.07 !important;
        }
        .highlighted {
            opacity: 1 !important;
        }
        .tooltip {
            position: absolute;
            padding: 8px;
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            pointer-events: none;
            font-size: 0.9rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .sampling-note {
            font-style: italic;
            border-top: 1px solid #e1e4e8;
            padding-top: 0.5rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="filter-group">
                <h4>Network Information</h4>
                <div id="metadata"></div>
            </div>

            <div class="controls">
                <input 
                    type="text" 
                    id="legislator-search" 
                    name="legislator-search" 
                    class="search-box" 
                    placeholder="Search legislators..."
                    autocomplete="off"
                >

                <div class="filter-group">
                    <h4>Minimum Collaborations</h4>
                    <input 
                        type="range" 
                        id="connection-threshold" 
                        name="connection-threshold"
                        min="1" 
                        max="20" 
                        value="10"
                    >
                    <div class="filter-value">10 collaborations</div>
                </div>

                <div class="filter-group">
                    <h4>Policy Area Filter</h4>
                    <select id="policy-filter" class="policy-filter">
                        <option value="all">All Policy Areas</option>
                    </select>
                    <div class="filter-value" id="policy-count"></div>
                </div>
            </div>

            <div class="stats">
                <div class="stat-box">
                    <div class="stat-value" id="active-legislators">0</div>
                    <div class="stat-label">Legislators</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="active-connections">0</div>
                    <div class="stat-label">Connections</div>
                </div>
            </div>

            <div class="node-info"></div>
        </div>
        <div class="main-content">
            <svg width="100%" height="100%"></svg>
            <div class="legend">
                <h4 style="margin-top: 0">Legend</h4>
                <div><span class="party-dot party-D"></span>Democrat</div>
                <div><span class="party-dot party-R"></span>Republican</div>
                <div><span class="party-dot party-I"></span>Independent</div>
                <div style="margin-top: 0.5rem; font-size: 0.8rem; color: #586069;">
                    Node size indicates number of collaborations<br>
                    Line thickness indicates collaboration strength<br>
                    Click node to highlight connections
                </div>
            </div>
        </div>
    </div>

    <script>
        const svg = d3.select("svg");
        const width = svg.node().clientWidth;
        const height = svg.node().clientHeight;
        let fullData = null;
        let currentElements = null;
        let selectedNode = null;
        let selectedState = null;
        let currentView = 'main'; // 'main', 'state', or 'individual'
    
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);
    
        const partyColor = party => {
            switch(party) {
                case 'D': return "#0366d6";
                case 'R': return "#d73a49";
                default: return "#6a737d";
            }
        };
    
        function initializePolicyFilter(data) {
            // Map policies to dropdown options (id = policy_id, text = policy_name)
            const policyOptions = data.policies.map(p => ({
                id: p.id,
                text: `${p.name} (${data.metadata.policies.counts[p.name] || 0})`
            }));

            // Initialize the Select2 dropdown with policy options
            $('#policy-filter').select2({
                placeholder: 'Search for a policy area...',
                allowClear: true,
                data: [
                    { id: 'all', text: 'All Policy Areas' },
                    ...policyOptions
                ]
            }).on('change', function() {
                const selectedPolicy = this.value; // Get selected policy ID
                if (fullData) {
                    // Redraw the network graph with the new filter applied
                    currentElements = drawNetwork(
                        fullData,
                        +d3.select("#connection-threshold").property("value"),
                        selectedPolicy
                    );
                }
            });
        }
    
        function updateMetadata(data) {
            const metadata = d3.select("#metadata");
            const congressRange = data.metadata.congress_range;
            
            // Format congress range
            const congressDisplay = congressRange.start === congressRange.end 
                ? `${congressRange.start}th`
                : `${congressRange.start}th-${congressRange.end}th`;
            
            // Count unique bills
            const uniqueBills = new Set(data.bills.map(b => b.bill_number)).size;

            // Format dates
            const formatDate = (dateStr) => {
                const date = new Date(dateStr);
                return new Intl.DateTimeFormat('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                }).format(date);
            };

            const startDate = formatDate(data.metadata.date_range.start);
            const endDate = formatDate(data.metadata.date_range.end);
            
            metadata.html(`
                <p>
                    Congress: ${congressDisplay}<br>
                    Dates: ${startDate} to ${endDate}<br>
                    Total Bills: ${uniqueBills}<br>
                    Total Policies: ${data.policies.length}
                </p>
            `);
        }
        
        const MAX_CONNECTIONS = 5000; // Adjust based on performance testing
        const SAMPLING_METHODS = {
            RANDOM: 'random',
            WEIGHTED: 'weighted'  // Preserves stronger collaborations
        };
        const SAMPLING_METHOD = SAMPLING_METHODS.RANDOM; // Choose your preferred method

        function filterNetwork(data, minConnections = 10, policyId = "all") {
            let filteredBills = data.bills;

            if (policyId !== "all") {
                filteredBills = data.bills.filter(b => String(b.policy_id) === String(policyId));
            }

            const validBills = new Set(filteredBills.map(b => b.bill_number));
            let filteredCollaborations = data.collaborations.filter(c => 
                validBills.has(c.bill_number)
            );

            // Calculate collaboration counts between pairs
            const collaborationCounts = {};
            filteredCollaborations.forEach(collab => {
                const key = [collab.source, collab.target].sort().join('-');
                collaborationCounts[key] = (collaborationCounts[key] || 0) + 1;
            });

            // Filter collaborations by minimum connections
            filteredCollaborations = filteredCollaborations.filter(collab => {
                const key = [collab.source, collab.target].sort().join('-');
                return collaborationCounts[key] >= minConnections;
            });

            // Sample connections if exceeding maximum
            let prefilterCollaborations_length = filteredCollaborations.length
            if (filteredCollaborations.length > MAX_CONNECTIONS) {
                filteredCollaborations = sampleConnections(filteredCollaborations, collaborationCounts);
            }

            // Get unique legislator IDs from sampled connections
            const activeIds = new Set();
            filteredCollaborations.forEach(collab => {
                activeIds.add(collab.source);
                activeIds.add(collab.target);
            });

            const uniqueLegislators = [...new Set(data.legislators.map(d => d.id))];
            const activeNodes = data.legislators.filter(d => 
                activeIds.has(d.id) && 
                uniqueLegislators.indexOf(d.id) === uniqueLegislators.lastIndexOf(d.id)
            );

            return {
                nodes: activeNodes,
                links: filteredCollaborations,
                counts: {
                    legislators: activeNodes.length,
                    connections: prefilterCollaborations_length,
                    bills: validBills.size,
                    sampled: filteredCollaborations.length > MAX_CONNECTIONS
                }
            };
        }

        // Sampling function
        function sampleConnections(collaborations, collaborationCounts) {
            if (SAMPLING_METHOD === SAMPLING_METHODS.RANDOM) {
                // Simple random sampling
                return shuffleArray(collaborations).slice(0, MAX_CONNECTIONS);
            } else {
                // Weighted sampling based on collaboration strength
                const weightedCollaborations = collaborations.map(collab => ({
                    ...collab,
                    weight: collaborationCounts[[collab.source, collab.target].sort().join('-')]
                }));

                // Sort by weight and take top connections
                return weightedCollaborations
                    .sort((a, b) => b.weight - a.weight)
                    .slice(0, MAX_CONNECTIONS);
            }
        }

        // Fisher-Yates shuffle for random sampling
        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
            
        function highlightConnections(node, elements) {
            if (selectedNode === node) {
                clearHighlighting(elements);
                return;
            }

            selectedNode = node;

            // Find connected nodes and links
            const connectedLinks = elements.links.filter(l => 
                l.source === node.id || l.target === node.id
            );

            const connectedNodes = new Set();
            connectedLinks.each(l => {
                connectedNodes.add(l.source);
                connectedNodes.add(l.target);
            });

            // Highlight nodes
            elements.nodes
                .classed("selected-node", d => d.id === node.id)
                .classed("dimmed", d => !connectedNodes.has(d.id) && d.id !== node.id);

            // Color and highlight links
            elements.links
                .style("stroke", l => {
                    if (l.source === node.id) {
                        // Find the target node's data
                        const targetNode = elements.nodes.filter(d => d.id === l.target).datum();
                        return targetNode ? partyColor(targetNode.party) : "#999";
                    } else if (l.target === node.id) {
                        // Find the source node's data
                        const sourceNode = elements.nodes.filter(d => d.id === l.source).datum();
                        return sourceNode ? partyColor(sourceNode.party) : "#999";
                    }
                    return "#999";
                })
                .style("stroke-opacity", l => 
                    l.source === node.id || l.target === node.id ? 0.1 : 0
                );

            // Update node info
            updateNodeInfo(node, elements.links.data(), fullData);
        }

        function clearHighlighting(elements) {
            selectedNode = null;

            elements.nodes
                .classed("selected-node", false)
                .classed("dimmed", false);
            elements.links
                .style("stroke", "#999")
                .style("stroke-opacity", 0.1);
        }

        // Add click handler to svg
        svg.on("click", (event) => {
            if (event.target.tagName === "svg") {
                clearHighlighting(currentElements);
            }
        });
        
        function calculateStatePositions(nodes, radius) {
            // Group nodes by state
            const stateGroups = {};
            nodes.forEach(node => {
                if (!stateGroups[node.state]) {
                    stateGroups[node.state] = [];
                }
                stateGroups[node.state].push(node);
            });

            // Sort states alphabetically to ensure consistent positioning
            const states = Object.keys(stateGroups).sort();
            const totalStates = states.length;
            const stateGap = 0.02; // Reduce gap between states
            const totalGaps = totalStates * stateGap;
            const availableAngle = 2 * Math.PI - totalGaps;
            const stateAngleStep = availableAngle / totalStates;

            // Position each node within its state group
            states.forEach((state, stateIndex) => {
                const stateNodes = stateGroups[state];
                const nodesInState = stateNodes.length;
                
                // Calculate the starting angle for this state group
                const stateStartAngle = (stateIndex * (stateAngleStep + stateGap)) - Math.PI / 2;
                
                // Distribute nodes within the state's arc
                const nodeAngleStep = stateAngleStep / Math.max(1, nodesInState);
                
                stateNodes.forEach((node, nodeIndex) => {
                    const angle = stateStartAngle + (nodeIndex * nodeAngleStep);
                    node.x = radius * Math.cos(angle);
                    node.y = radius * Math.sin(angle);
                    node.stateAngle = stateStartAngle + (stateAngleStep / 2); // Store for label positioning
                });
            });

            return { stateGroups, states };
        }

        function transitionToStateView(state, nodes, links, filtered, radius) {
            const t = d3.transition().duration(750);
            const innerRadius = radius * 0.5;

            // Find all nodes in selected state
            const stateNodes = filtered.nodes.filter(n => n.state === state);
            const angleStep = (2 * Math.PI) / stateNodes.length;

            // Find all connected nodes and links for the selected state
            const connectedNodeIds = new Set();
            const connectedLinkIds = new Set();
            
            // Add selected state nodes
            stateNodes.forEach(n => connectedNodeIds.add(n.id));
            
            // Find all connections to/from selected state nodes
            filtered.links.forEach(link => {
                const sourceNode = filtered.nodes.find(n => n.id === link.source);
                const targetNode = filtered.nodes.find(n => n.id === link.target);
                
                if (sourceNode?.state === state || targetNode?.state === state) {
                    connectedLinkIds.add(link.source + '-' + link.target);
                    connectedNodeIds.add(link.source);
                    connectedNodeIds.add(link.target);
                }
            });

            // Update nodes
            nodes.transition(t)
                .attr("transform", d => {
                    if (d.state === state) {
                        const idx = stateNodes.indexOf(d);
                        const angle = idx * angleStep - Math.PI / 2;
                        const newX = innerRadius * Math.cos(angle);
                        const newY = innerRadius * Math.sin(angle);
                        return `translate(${newX},${newY})`;
                    }
                    return `translate(${d.x},${d.y})`;
                })
                .style("opacity", d => connectedNodeIds.has(d.id) ? 1 : 0.1);

            // Update links
            links.transition(t)
                .style("opacity", d => {
                    const linkId = d.source + '-' + d.target;
                    return connectedLinkIds.has(linkId) ? 0.6 : 0.05;
                })
                .attr("d", d => {
                    const source = filtered.nodes.find(n => n.id === d.source);
                    const target = filtered.nodes.find(n => n.id === d.target);
                    
                    if (!source || !target) return null;
                    
                    let sourceX = source.x;
                    let sourceY = source.y;
                    let targetX = target.x;
                    let targetY = target.y;
                    
                    // Adjust positions for selected state nodes
                    if (source.state === state) {
                        const idx = stateNodes.indexOf(source);
                        const angle = idx * angleStep - Math.PI / 2;
                        sourceX = innerRadius * Math.cos(angle);
                        sourceY = innerRadius * Math.sin(angle);
                    }
                    
                    if (target.state === state) {
                        const idx = stateNodes.indexOf(target);
                        const angle = idx * angleStep - Math.PI / 2;
                        targetX = innerRadius * Math.cos(angle);
                        targetY = innerRadius * Math.sin(angle);
                    }
                    
                    const dx = targetX - sourceX;
                    const dy = targetY - sourceY;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 2;
                    
                    return `M${sourceX},${sourceY}A${dr},${dr} 0 0,1 ${targetX},${targetY}`;
                });
        }

        function drawNetwork(data, minConnections = 10, policyId = "all") {
            svg.selectAll("*").remove();
            
            const filtered = filterNetwork(data, minConnections, policyId);
            let selectedState = null;
            let selectedNode = null;
            let currentView = 'main';
            
            d3.select("#active-legislators").text(filtered.counts.legislators);
            d3.select("#active-connections")
                .html(`${filtered.counts.connections}${filtered.counts.sampled ? '*' : ''}`);
            
            if (filtered.counts.sampled) {
                // Add sampling indicator to legend
                d3.select(".legend")
                    .append("div")
                    .attr("class", "sampling-note")
                    .style("font-size", "0.8rem")
                    .style("color", "#586069")
                    .style("margin-top", "0.5rem")
                    .text(`* Showing ${MAX_CONNECTIONS} representative connections out of ${filtered.counts.connections} total`);
            } else {
                d3.select(".sampling-note").remove();
            }

            const g = svg.append("g")
                .attr("transform", `translate(${width/2},${height/2})`);

            const radius = Math.min(width, height) / 2.5;
            const labelRadius = radius + 60;

            const { states } = calculateStatePositions(filtered.nodes, radius);

            // Create links
            const links = g.append("g")
                .selectAll("path")
                .data(filtered.links)
                .join("path")
                .style("stroke", "#999")
                .style("stroke-opacity", 0.05)
                .style("fill", "none")
                .style("stroke-width", d => 1 + Math.sqrt(d.value || 1))
                .attr("d", createLinkPath);

            // Add state labels
            const stateLabels = g.append("g")
                .attr("class", "state-labels")
                .selectAll("text")
                .data(states)
                .join("text")
                .attr("class", d => `state-label state-label-${d}`)
                .text(d => d)
                .attr("x", (d, i) => {
                    const angle = (i * (2 * Math.PI / states.length)) - Math.PI / 2;
                    return labelRadius * Math.cos(angle);
                })
                .attr("y", (d, i) => {
                    const angle = (i * (2 * Math.PI / states.length)) - Math.PI / 2;
                    return labelRadius * Math.sin(angle);
                })
                .attr("text-anchor", "middle")
                .attr("alignment-baseline", "middle")
                .style("font-size", "12px")
                .style("font-weight", "bold")
                .style("cursor", "pointer")
                .attr("position", "fixed")
                .on("click", (event, d) => {
                    event.stopPropagation();
                    if (currentView === 'main') {
                        transitionToStateView(d);
                    } else if (currentView === 'state' && selectedState !== d) {
                        transitionToStateView(d);
                    }
                });

            // Create nodes
            const nodes = g.append("g")
                .selectAll("circle")
                .data(filtered.nodes)
                .join("circle")
                .attr("r", d => 5 + .5*(d.metrics?.total_collaborations || 0)**(1/2))
                .attr("transform", d => `translate(${d.x},${d.y})`)
                .style("fill", d => partyColor(d.party))
                .style("stroke", "#fff")
                .style("stroke-width", 1.5)
                .style("cursor", "pointer");

            function createLinkPath(d) {
                const source = getNodePosition(d.source);
                const target = getNodePosition(d.target);
                if (!source || !target) return null;
                
                const dx = target.x - source.x,
                    dy = target.y - source.y,
                    dr = Math.sqrt(dx * dx + dy * dy) * 2;
                
                return `M${source.x},${source.y}A${dr},${dr} 0 0,1 ${target.x},${target.y}`;
            }

            function getNodePosition(nodeId) {
                const node = filtered.nodes.find(n => n.id === nodeId);
                if (!node) return null;

                if (currentView === 'individual' && selectedNode && node.id === selectedNode.id) {
                    return { x: 0, y: 0 };
                } else if ((currentView === 'state' || currentView === 'individual') && 
                        node.state === selectedState) {
                    const stateNodes = filtered.nodes.filter(n => n.state === selectedState);
                    const idx = stateNodes.indexOf(node);
                    const angleStep = (2 * Math.PI) / stateNodes.length;
                    const angle = idx * angleStep - Math.PI / 2;
                    const innerRadius = radius * 0.5;
                    return {
                        x: innerRadius * Math.cos(angle),
                        y: innerRadius * Math.sin(angle)
                    };
                }
                return { x: node.x, y: node.y };
            }
            
            function calculateRingPositions(nodes, excludeState = null) {
                const activeStates = [...new Set(nodes.map(n => n.state))].filter(s => s !== excludeState).sort();
                const angleStep = (2 * Math.PI) / activeStates.length;
                
                // Create mapping of states to their new positions
                const statePositions = {};
                activeStates.forEach((state, i) => {
                    const angle = i * angleStep - Math.PI / 2;
                    statePositions[state] = angle;
                });
                
                return statePositions;
            }

            function createStateLabel(state, x, y) {
                const label = g.append("g")
                    .attr("class", `state-label-group-${state}`)
                    .attr("transform", `translate(${x},${y})`);
                    
                label.append("text")
                    .text(state)
                    .attr("text-anchor", "middle")
                    .attr("alignment-baseline", "middle")
                    .style("font-size", "12px")
                    .style("font-weight", "bold");
                    
                return label;
            }

            function highlightConnections(node) {
                const connectedNodes = new Set([node.id]);
                const connectedLinks = new Set();

                filtered.links.forEach(link => {
                    if (link.source === node.id) {
                        connectedNodes.add(link.target);
                        connectedLinks.add(`${link.source}-${link.target}`);
                    }
                    if (link.target === node.id) {
                        connectedNodes.add(link.source);
                        connectedLinks.add(`${link.source}-${link.target}`);
                    }
                });

                nodes.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0.1);

                links
                    .style("stroke", link => {
                        const linkId = `${link.source}-${link.target}`;
                        if (connectedLinks.has(linkId)) {
                            if (link.source === node.id) {
                                const targetNode = filtered.nodes.find(n => n.id === link.target);
                                return partyColor(targetNode.party);
                            }
                            if (link.target === node.id) {
                                const sourceNode = filtered.nodes.find(n => n.id === link.source);
                                return partyColor(sourceNode.party);
                            }
                        }
                        return "#999";
                    })
                    .style("stroke-opacity", link => {
                        const linkId = `${link.source}-${link.target}`;
                        return connectedLinks.has(linkId) ? 0.1 : 0.00;
                    });

                updateNodeInfo(node, filtered.links, fullData);
            }

            function highlightStateConnections(state) {
                const connectedNodes = new Set();
                const connectedLinks = new Set();

                // Add all state nodes
                filtered.nodes.filter(n => n.state === state)
                    .forEach(node => connectedNodes.add(node.id));

                // Find all connections to/from state nodes
                filtered.links.forEach(link => {
                    const sourceNode = filtered.nodes.find(n => n.id === link.source);
                    const targetNode = filtered.nodes.find(n => n.id === link.target);
                    
                    if (sourceNode?.state === state || targetNode?.state === state) {
                        connectedNodes.add(link.source);
                        connectedNodes.add(link.target);
                        connectedLinks.add(`${link.source}-${link.target}`);
                    }
                });

                nodes.style("opacity", d => connectedNodes.has(d.id) ? 1 : 0.1);
                
                links
                    .style("stroke", "#999") // Ensure links are grey in state view
                    .style("stroke-opacity", link => {
                        const linkId = `${link.source}-${link.target}`;
                        return connectedLinks.has(linkId) ? 0.05 : 0.00;
                    });
            }

            function transitionToStateView(state) {
                selectedState = state;
                currentView = 'state';
                const t = d3.transition().duration(750);
                const innerRadius = radius * 0.5;
                
                // Calculate new positions for remaining states to close the gap
                const statePositions = calculateRingPositions(filtered.nodes, state);

                // Move selected state label to slightly above center
                d3.select(`.state-label-group-${state}`)
                    .transition(t)
                    .attr("transform", `translate(0,0)`)
                    .style("font-size", "16px");  // Make label bigger in center
                    
                // Transition other state labels
                Object.entries(statePositions).forEach(([s, angle]) => {
                    d3.select(`.state-label-group-${s}`)
                        .transition(t)
                        .attr("transform", `translate(
                            ${labelRadius * Math.cos(angle)},
                            ${labelRadius * Math.sin(angle)}
                        )`);
                });
                
                stateLabels.transition(t)
                    .attr("x", d => {
                        if (d === state) {
                            return 0; // Center
                        } else {
                            const angle = statePositions[d];
                            return labelRadius * Math.cos(angle);
                        }
                    })
                    .attr("y", d => {
                        if (d === state) {
                            return -labelRadius/2 - 20; // Slightly Above Center
                        } else {
                            const angle = statePositions[d];
                            return labelRadius * Math.sin(angle);
                        }
                    })
                    .style("font-size", d => d === state ? "18px" : "12px")
                    .style("opacity", d => d === state ? 1 : .9);
                
                // Move nodes
                nodes.transition(t)
                    .attr("transform", d => {
                        if (d.state === state) {
                            const stateNodes = filtered.nodes.filter(n => n.state === state);
                            const idx = stateNodes.indexOf(d);
                            const angleStep = (2 * Math.PI) / stateNodes.length;
                            const angle = idx * angleStep - Math.PI / 2;
                            return `translate(${innerRadius * Math.cos(angle)},${innerRadius * Math.sin(angle)})`;
                        } else {
                            const angle = statePositions[d.state];
                            return `translate(${radius * Math.cos(angle)},${radius * Math.sin(angle)})`;
                        }
                    });

                // Update links with optimized rendering
                links.transition(t)
                    .attr("d", d => {
                        const source = filtered.nodes.find(n => n.id === d.source);
                        const target = filtered.nodes.find(n => n.id === d.target);
                        
                        if (!source || !target) return null;
                        
                        let sourceX, sourceY, targetX, targetY;
                        const sourceInState = source.state === state;
                        const targetInState = target.state === state;
                        
                        // Calculate positions
                        if (sourceInState) {
                            const stateNodes = filtered.nodes.filter(n => n.state === state);
                            const idx = stateNodes.indexOf(source);
                            const angleStep = (2 * Math.PI) / stateNodes.length;
                            const angle = idx * angleStep - Math.PI / 2;
                            sourceX = innerRadius * Math.cos(angle);
                            sourceY = innerRadius * Math.sin(angle);
                        } else {
                            const angle = statePositions[source.state];
                            sourceX = radius * Math.cos(angle);
                            sourceY = radius * Math.sin(angle);
                        }
                        
                        if (targetInState) {
                            const stateNodes = filtered.nodes.filter(n => n.state === state);
                            const idx = stateNodes.indexOf(target);
                            const angleStep = (2 * Math.PI) / stateNodes.length;
                            const angle = idx * angleStep - Math.PI / 2;
                            targetX = innerRadius * Math.cos(angle);
                            targetY = innerRadius * Math.sin(angle);
                        } else {
                            const angle = statePositions[target.state];
                            targetX = radius * Math.cos(angle);
                            targetY = radius * Math.sin(angle);
                        }
                        
                        // Optimize edge rendering based on node positions
                        if (sourceInState && targetInState) {
                            // Both nodes in inner circle - render inside
                            const dr = Math.sqrt((targetX - sourceX)**2 + (targetY - sourceY)**2) * 1.5;
                            return `M${sourceX},${sourceY}A${dr},${dr} 0 0,1 ${targetX},${targetY}`;
                        } else {
                            // At least one node on outer ring - render outside
                            const dr = Math.sqrt((targetX - sourceX)**2 + (targetY - sourceY)**2) * 2;
                            return `M${sourceX},${sourceY}A${dr},${dr} 0 0,1 ${targetX},${targetY}`;
                        }
                    });

                highlightStateConnections(state);
            }

            function transitionToIndividualView(node) {
                selectedNode = node;
                currentView = 'individual';
                const t = d3.transition().duration(750);

                nodes.transition(t)
                    .attr("transform", d => {
                        const pos = getNodePosition(d.id);
                        return `translate(${pos.x},${pos.y})`;
                    });

                links.transition(t)
                    .attr("d", createLinkPath);

                highlightConnections(node);
            }

            function resetToMainView() {
                selectedState = null;
                selectedNode = null;
                currentView = 'main';
                const t = d3.transition().duration(750);
                
                // Reset state labels to original positions
                states.forEach((state, i) => {
                    const angle = (i * (2 * Math.PI / states.length)) - Math.PI / 2;
                    d3.select(`.state-label-group-${state}`)
                        .transition(t)
                        .attr("transform", `translate(
                            ${labelRadius * Math.cos(angle)},
                            ${labelRadius * Math.sin(angle)}
                        )`)
                        .style("font-size", "12px");  // Reset font size
                });
                
                stateLabels.transition(t)
                    .attr("x", (d, i) => {
                        const angle = (i * (2 * Math.PI / states.length)) - Math.PI / 2;
                        return labelRadius * Math.cos(angle);
                    })
                    .attr("y", (d, i) => {
                        const angle = (i * (2 * Math.PI / states.length)) - Math.PI / 2;
                        return labelRadius * Math.sin(angle);
                    })
                    .style("font-size", "12px")
                    .style("opacity", 1);
                // Reset nodes and links
                nodes.transition(t)
                    .attr("transform", d => `translate(${d.x},${d.y})`)
                    .style("opacity", 1);

                links.transition(t)
                    .attr("d", createLinkPath)
                    .style("stroke", "#999")
                    .style("stroke-opacity", 0.05);
            }

            function resetToStateView() {
                selectedNode = null;
                currentView = 'state';
                const t = d3.transition().duration(750);

                // First reset all links to default state
                links.transition(t)
                    .style("stroke", "#999")
                    .style("stroke-opacity", 0.0)
                    .attr("d", createLinkPath);

                nodes.transition(t)
                    .attr("transform", d => {
                        const pos = getNodePosition(d.id);
                        return `translate(${pos.x},${pos.y})`;
                    });

                // After transition, reapply state highlighting
                t.end().then(() => {
                    highlightStateConnections(selectedState);
                });
            }

            // Node interactions
            nodes
                .on("mouseover", (event, d) => {
                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html(`
                        ${d.name} (${d.party}-${d.state})<br/>
                        District: ${d.district || 'At-large'}<br/>
                        Collaborations: ${d.metrics?.total_collaborations || 0}
                    `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 28) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                })
                .on("click", (event, d) => {
                    event.stopPropagation();

                    if (currentView === 'main') {
                        transitionToStateView(d.state);
                    } else if (currentView === 'state') {
                        if (d.state === selectedState) {
                            transitionToIndividualView(d);
                        } else {
                            transitionToStateView(d.state);
                        }
                    } else if (currentView === 'individual') {
                        if (d.id === selectedNode.id) {
                            resetToStateView();
                        } else if (d.state === selectedState) {
                            transitionToIndividualView(d);
                        } else {
                            transitionToStateView(d.state);
                        }
                    }
                });

            // Background click handler
            svg.on("click", (event) => {
                if (event.target.tagName === "svg") {
                    if (currentView === 'individual') {
                        resetToStateView();
                    } else if (currentView === 'state') {
                        resetToMainView();
                    }
                }
            });

            return { nodes, links };
        }
    
        function updateNodeInfo(node, links, data) {
            const nodeLinks = links.filter(l => 
                l.source === node.id || l.target === node.id
            );
            
            // Get unique bill numbers for this node's connections
            const nodeBills = new Set(nodeLinks.map(l => l.bill_number));
            const relevantBills = data.bills.filter(b => nodeBills.has(b.bill_number));

            // Create a mapping of bill_id to policy names
            const billPolicyMap = {};
            relevantBills.forEach(bill => {
                if (!billPolicyMap[bill.bill_number]) {
                    billPolicyMap[bill.bill_number] = [];
                }
                if (!billPolicyMap[bill.bill_number].includes(bill.policy_name)) {
                    billPolicyMap[bill.bill_number].push(bill.policy_name);
                }
            });

            // Count policies for display
            const policyCount = {};
            relevantBills.forEach(bill => {
                policyCount[bill.policy_name] = (policyCount[bill.policy_name] || 0) + 1;
            });

            // Create a Set to track displayed bills
            const displayedBillIds = new Set();
            const uniqueBills = [];

            // Collect unique bills
            relevantBills.forEach(bill => {
                if (!displayedBillIds.has(bill.bill_number)) {
                    displayedBillIds.add(bill.bill_number);
                    uniqueBills.push(bill);
                }
            });

            const nodeInfo = d3.select(".node-info");
            nodeInfo.html(`
                <h3>${node.name}</h3>
                <p>
                    Party: ${node.party}<br>
                    State: ${node.state}${node.district ? `-${node.district}` : ''}<br>
                    Total Collaborations: ${node.metrics?.total_collaborations || 0}<br>
                    Connected Legislators: ${new Set([
                        ...nodeLinks.map(l => l.source),
                        ...nodeLinks.map(l => l.target)
                    ]).size - 1}
                </p>
                <div>
                    <h4>Top Policy Areas</h4>
                    ${Object.entries(policyCount)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([policy, count]) => `
                            <div class="policy-tag">
                                ${policy} (${count})
                            </div>
                        `).join('')}
                </div>
                <div class="bill-list">
                    <h4>Recent Collaborative Bills</h4>
                    ${uniqueBills.slice(0, 25).map(bill => {
                        const policyTags = billPolicyMap[bill.bill_number].slice(0, 3).join(', '); // Limit to 3 tags
                        const titleDisplay = bill.title.length < 100 ? bill.title : bill.title.substring(0, 120) + '...';
                        return `
                            <div class="bill-item">
                                <strong>No.${bill.bill_number}</strong>
                                <div>${titleDisplay}</div>
                                <div class="bill-policy">${policyTags}</div>
                                <div style="font-size: 0.8rem; color: #586069; margin-top: 0.3rem;">
                                    Last Action: ${bill.latest_action_date}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `);
        }

        // Performance monitoring
        let lastRenderTime = 0;
        function monitorPerformance() {
            const currentTime = performance.now();
            const renderTime = currentTime - lastRenderTime;
            lastRenderTime = currentTime;
            
            if (renderTime > 3000) { // More than 3 second
                console.warn(`Slow render detected: ${renderTime.toFixed(0)}ms`);
                // Could automatically adjust MAX_CONNECTIONS based on performance
                // MAX_CONNECTIONS = Math.floor(MAX_CONNECTIONS * 0.8);
            }
        }
    
        // Initialize visualization
        async function initializeVisualization() {
            try {
                console.log('Initializing visualization...');
                
                console.log('Fetching data from API...');
                const response = await fetch('/api/network-data');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Data received from API');

                if (!data || !data.legislators || !data.bills || !data.collaborations) {
                    throw new Error('Invalid data structure received from API');
                }
                
                // Set global data
                fullData = data;
                console.log('Data loaded:', {
                    legislators: data.legislators.length,
                    bills: data.bills.length,
                    collaborations: data.collaborations.length,
                    policies: data.policies.length
                });
                
                // Initialize components
                console.log('Initializing components...');
                initializePolicyFilter(data);
                updateMetadata(data);
                
                // Draw initial network
                console.log('Drawing network...');
                currentElements = drawNetwork(data);
                if (!currentElements) {
                    throw new Error("Failed to create network elements");
                }
                console.log('Network drawn successfully');
                
                // Setup connection threshold slider
                const thresholdSlider = d3.select("#connection-threshold");
                const thresholdValue = d3.select(".filter-value");
                
                thresholdSlider.on("input", function() {
                    const value = +this.value;
                    thresholdValue.text(`${value} collaborations`);
                    selectedNode = null;
                    const start = performance.now();
                    currentElements = drawNetwork(
                        data,
                        value,
                        $('#policy-filter').val()
                    );
                    monitorPerformance();
                });
                                
                // Setup search functionality
                d3.select("#legislator-search").on("input", function() {
                    const searchTerm = this.value.toLowerCase();
                    if (!currentElements) return;
                    
                    currentElements.nodes
                        .style("opacity", d => 
                            d.name.toLowerCase().includes(searchTerm) ? 1 : 0.2
                        );
                    currentElements.links
                        .style("opacity", .05);
                });
                
            } catch (error) {
                console.error("Error loading or processing data:", error);
                d3.select(".main-content")
                    .append("div")
                    .attr("class", "error")
                    .html(`
                        <h3>Error Loading Network Data</h3>
                        <p>${error.message}</p>
                        <p>Please check that the API server is running.</p>
                        <pre>${error.stack}</pre>
                    `);
            }
        }
    
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, starting initialization...');
            initializeVisualization();
        });
    </script>
</body>
</html>